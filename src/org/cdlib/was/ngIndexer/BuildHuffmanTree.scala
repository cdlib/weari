package org.cdlib.was.ngIndexer;

import scala.collection.mutable.{HashMap,PriorityQueue};
import scala.collection.Map;
import scala.io.Source;
import org.archive.net.UURIFactory;
import org.apache.commons.httpclient.URIException;

object BuildHuffmanTree {
  class NodeElement (val node : HuffmanNode, val prob : Double)
    extends Ordered[NodeElement] {
    
      // override def <  (that : NodeElement) = that.prob <  this.prob;
      // override def <= (that : NodeElement) = that.prob <= this.prob;
      // override def >  (that : NodeElement) = that.prob >  this.prob;
      // override def >= (that : NodeElement) = that.prob >= this.prob;
      def compare (that : NodeElement) =
        -1 * this.prob.compare(that.prob);
      override def toString = "%s (%f)".format(node, prob);
    }
  
  val allowedBytes = Set[Byte](
    /* gen-delims */
    0x3a, /* : */
    0x2f, /* / */
    0x3f, /* ? */
    0x23, /* # */
    0x5b, /* [ */
    0x5d, /* ] */
    0x40, /* @ */
    /* sub-delims */
    0x21, /* ! */
    0x24, /* $ */
    0x26, /* & */
    0x27, /* ' */
    0x28, /* ( */
    0x2a, /* * */
    0x2b, /* + */
    0x2c, /* , */
    /* unreserved */
    0x3b, /* ; */
    0x30, /* 0 */
    0x31, /* 1 */
    0x32, /* 2 */
    0x33, /* 3 */
    0x34, /* 4 */
    0x35, /* 5 */
    0x36, /* 6 */
    0x37, /* 7 */
    0x38, /* 8 */
    0x39, /* 9 */
    0x3d, /* = */
    /* alpha */
    0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a,
    /* ALPHA */
    0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a,
    0x2d, /* - */
    0x2e, /* . */
    0x5f, /* - */
    0x7e, /* ~ */
    
    0x25, /* % */
    
    /* invalid, but generated by UURI */
    0x7c  /* | */
  );
    
  def buildFreqTable(path : String) : Pair[Int,Map[Byte, Int]] = {
    var freqTable = new HashMap[Byte, Int]();
    var occur = 0;

    /* init table */
    for (i <- allowedBytes) {
      /* works as long as i < 128 */
      val b : Byte = i.asInstanceOf[Byte];
      freqTable.update(b, 1);
      occur = occur + 1;
    }

    for (l <- Source.fromFile(path).getLines) {
      /* null terminator */
      freqTable.update(0, 1 + freqTable.get(0).getOrElse(0));
      occur = occur + 1;
      try {
        val uuri = UURIFactory.getInstance(l);
        for (c <- uuri.toString.getBytes("UTF-8")) {
          occur = occur + 1;
          freqTable.get(c) match {
            case None          => {
              System.err.println(c);
            }
            case Some(i : Int) => freqTable.update(c, i + 1);
          }
        }
      } catch {
        case ex : URIException => {
          System.err.println(l);
        }
      }
    }
    
    return Pair(occur, freqTable);
  }

  def buildTree (occur : Int, freqTable : Map[Byte, Int]) : HuffmanNode = {
    var q = new PriorityQueue[NodeElement]();
    for (kv <- freqTable) {
      val n = new LeafNode(kv._1);
      val o : Double = kv._2;
      val e = new NodeElement(n, o/occur);
      q.enqueue(e);
    }
    
    while (q.size > 2) { /* size is funny with priority queue */
      val a = q.dequeue;
      val b = q.dequeue;
      val intNode = new InternalNode(a.node, b.node);
      q.enqueue(new NodeElement(intNode, a.prob + b.prob));
    }
    val e = q.dequeue;
    val tree = e.node;
    return e.node;
  }

  def prettyPrintTree (t : HuffmanNode, indent : String) {
    t match {
      case n : InternalNode => {
        System.out.println("%s0:".format(indent));
        prettyPrintTree(n.left, indent + "  ");
        System.out.println("%s1:".format(indent));
        prettyPrintTree(n.right, indent + "  ");
      }
      case n : LeafNode => {
        System.out.println("%s%s".format(indent, n.byte))
      }
    }
  }

  def dumpTree (t : HuffmanNode) : String = {
    t match {
      case n : InternalNode => {
        return "new InternalNode(%s, %s)".format(dumpTree(n.left), 
                                                 dumpTree(n.right));
      }
      case n : LeafNode => {
        return "new LeafNode(%d)".format(n.byte);
      }
    }
  }
  
  def buildPrintTable (t : HuffmanNode) : Map[Byte, Seq[Boolean]] = {
    var printTable = new HashMap[Byte, Seq[Boolean]]();
    def process (n : HuffmanNode, sofar : List[Boolean]) {
      n match {
        case n1 : InternalNode => {
          process(n1.left, sofar ::: List(false));
          process(n1.right, sofar ::: List(true));
        }
        case n1 : LeafNode => {
          printTable.update(n1.byte, sofar);
        }
      }
    }
    process(t, List[Boolean]());
    return printTable;
  }

  def main (args : Array[String]) {
    val t = buildFreqTable(args(0));
    val tree = buildTree(t._1, t._2);
    val printTable = buildPrintTable(tree);
    System.out.println(printTable);
  }
}
