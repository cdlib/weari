package org.cdlib.was.ngIndexer;

import scala.collection.mutable.{HashMap,PriorityQueue};
import scala.collection.Map;
import scala.io.Source;
import org.archive.net.UURIFactory;
import org.apache.commons.httpclient.URIException;
import java.util.regex._;

object BuildHuffmanTree {
  class NodeElement (val node : DecoderNode, val prob : Double)
    extends Ordered[NodeElement] {
    
      // override def <  (that : NodeElement) = that.prob <  this.prob;
      // override def <= (that : NodeElement) = that.prob <= this.prob;
      // override def >  (that : NodeElement) = that.prob >  this.prob;
      // override def >= (that : NodeElement) = that.prob >= this.prob;
      def compare (that : NodeElement) =
        -1 * this.prob.compare(that.prob);
      override def toString = "%s (%f)".format(node, prob);
    }
  
  val allowedBytes = Set[Byte](
    /* gen-delims */
    0x3a, /* : */
    0x2f, /* / */
    0x3f, /* ? */
    0x23, /* # */
    0x5b, /* [ */
    0x5d, /* ] */
    0x40, /* @ */
    /* sub-delims */
    0x21, /* ! */
    0x24, /* $ */
    0x26, /* & */
    0x27, /* ' */
    0x28, /* ( */
    0x2a, /* * */
    0x2b, /* + */
    0x2c, /* , */
    /* unreserved */
    0x3b, /* ; */
    0x30, /* 0 */
    0x31, /* 1 */
    0x32, /* 2 */
    0x33, /* 3 */
    0x34, /* 4 */
    0x35, /* 5 */
    0x36, /* 6 */
    0x37, /* 7 */
    0x38, /* 8 */
    0x39, /* 9 */
    0x3d, /* = */
    /* alpha */
    0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a,
    /* ALPHA */
    0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a,
    0x2d, /* - */
    0x2e, /* . */
    0x5f, /* - */
    0x7e, /* ~ */
    
    0x25, /* % */
    
    /* invalid, but generated by UURI */
    0x7c  /* | */
  );
  
  val longStrings = Set[String]("http://",
                                ".com/",
                                ".org/",
                                ".net/");
  
  def buildFreqTable(path : String) : Pair[Int,Map[List[Byte], Int]] = {
    var freqTable = new HashMap[List[Byte], Int]();
    var occur = 0;

    /* init table */
    for (i <- allowedBytes) {
      /* works as long as i < 128 */
      val b : Byte = i.asInstanceOf[Byte];
      freqTable.update(List(b), 1);
      occur = occur + 1;
    }

    for (l <- Source.fromFile(path).getLines) {
      /* null terminator */
      freqTable.update(List(0), 1 + freqTable.get(List(0)).getOrElse(0));
      occur = occur + 1;
      try {
        val uuri = UURIFactory.getInstance(l);
        var s = uuri.toString;
        for (longString <- longStrings) {
          val matcher = Pattern.compile(longString).matcher(s);
          while (matcher.find) {
            s = matcher.replaceFirst("");
            occur = occur + longString.size;
            val b = longString.getBytes.toList;
            freqTable.update(b, longString.size + freqTable.get(b).getOrElse(0));
          }
        }
        val bytes = s.getBytes("UTF-8");
        for (b <- bytes) {
          occur = occur + 1;
          freqTable.get(List(b)) match {
            case None          => System.err.println(b);
            case Some(i : Int) => freqTable.update(List(b), i + 1);
          }
        }
      } catch {
        case ex : URIException => {
          System.err.println(l);
        }
      }
    }
    
    return Pair(occur, freqTable);
  }

  def buildDecoderTree (occur : Int, freqTable : Map[List[Byte], Int]) : DecoderNode = {
    var q = new PriorityQueue[NodeElement]();
    for (kv <- freqTable) {
      val n = new LeafNode(kv._1);
      val o : Double = kv._2;
      val e = new NodeElement(n, o/occur);
      q.enqueue(e);
    }
    
    while (q.size > 2) { /* size is funny with priority queue */
      val a = q.dequeue;
      val b = q.dequeue;
      val intNode = new InternalNode(a.node, b.node);
      q.enqueue(new NodeElement(intNode, a.prob + b.prob));
    }
    val e = q.dequeue;
    val tree = e.node;
    return e.node;
  }

  def prettyPrintTree (t : DecoderNode, indent : String) {
    t match {
      case n : InternalNode => {
        System.out.println("%s0:".format(indent));
        prettyPrintTree(n.left, indent + "  ");
        System.out.println("%s1:".format(indent));
        prettyPrintTree(n.right, indent + "  ");
      }
      case n : LeafNode => {
        System.out.println("%s%s".format(indent, n.bytes))
      }
    }
  }

  def dumpTree (t : DecoderNode) : String = {
    t match {
      case n : InternalNode => {
        return "new InternalNode(%s, %s)".format(dumpTree(n.left), 
                                                 dumpTree(n.right));
      }
      case n : LeafNode => {
        return "new LeafNode(%d)".format(n.bytes);
      }
    }
  }

  def processDecoderTree (tree : DecoderNode, f : (LeafNode, Seq[Boolean])=>Unit) {
    def process (n : DecoderNode, sofar : List[Boolean]) {
      n match {
        case n1 : InternalNode => {
          process(n1.left, sofar ::: List(false));
          process(n1.right, sofar ::: List(true));
        }
        case n1 : LeafNode => f (n1, sofar);
      }
    }
    process(tree, List[Boolean]());
  }

  def buildEncoderList (t : DecoderNode) : List[Pair[List[Byte], Seq[Boolean]]] = {
    var encoderList = List[Pair[List[Byte], Seq[Boolean]]]();
    processDecoderTree (t, (n, bits)=>{
      if (n.bytes.size > 1) {
        encoderList = Pair(n.bytes.toList, bits) :: encoderList
      }
    });
    return encoderList.sort((e1,e2)=>e1._1.size>e2._1.size);
  }

  def buildEncoderMap (t : DecoderNode) : Map[Byte, Seq[Boolean]] = {
    var encoderMap = new HashMap[Byte, Seq[Boolean]]();
    processDecoderTree (t, (n, bits)=>{
      if (n.bytes.size == 1) {
        encoderMap.update(n.bytes.first, bits);
      }
    });
    return encoderMap;
  }
  
  def main (args : Array[String]) {
    val t = buildFreqTable(args(0));
    val tree = buildDecoderTree(t._1, t._2);
    val encoderTree = buildEncoderList(tree);
    val encoderMap = buildEncoderMap(tree);
  }
}
